# ДЗ 6.1

<details><summary>Введение</summary>

> Перед выполнением задания вы можете ознакомиться с [дополнительными материалами](https://github.com/netology-code/virt-homeworks/tree/master/additional/README.md).

</details>



<details><summary>Задача 1</summary>

> Архитектор ПО решил проконсультироваться у вас, какой тип БД 
> лучше выбрать для хранения определенных данных.
> 
> Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:
> 
> - Электронные чеки в json виде
> - Склады и автомобильные дороги для логистической компании
> - Генеалогические деревья
> - Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации
> - Отношения клиент-покупка для интернет-магазина
> 
> Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.

</details>
<details><summary>Задача 1 - Решение</summary>
> Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.

> - Электронные чеки в json виде

Подойдёт NoSQL база, например MongoDB. Json для неё - нативный способ хранения данных. Работать со связями многие-ко-многим в NoSQL базе удобней, чем SQL.

> - Склады и автомобильные дороги для логистической компании

Предполагается поиск какого-то пути по дорогам, логика подсказывает что подойдут графовые DB. OpenStreetMaps [использует PostgreSQL](https://wiki.openstreetmap.org/wiki/Database) в качестве основного хранилища данных. 

Есть отдельный вид [пространственных баз данных](https://en.wikipedia.org/wiki/Spatial_database) - в основном это расширения или встроенные возможности СУБД разных типов, реляционных, графовых и документо-ориентированных.

> - Генеалогические деревья

Подойдут реляционные DB, это позволит гарантировать связанность данных, чтобы при удалении какая-то связь родственников не выпала и не оказалось "разорванного" генеалогического древа.

> - Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации

Для хранения кеша лучше подходят NoSQL базы, т.к. работают быстро. Для этой цели часто используют Memcached. 

> - Отношения клиент-покупка для интернет-магазина

Реляционная DB. За годы они хорошо зарекомендовали себя в сфере eCommerce.
</details>
<details><summary>Задача 2</summary>

> Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно 
> CAP-теореме. Какой классификации по CAP-теореме соответствует ваша система, если 
> (каждый пункт - это отдельная реализация вашей системы и для каждого пункта надо привести классификацию):
> 
> - Данные записываются на все узлы с задержкой до часа (асинхронная запись)
> - При сетевых сбоях, система может разделиться на 2 раздельных кластера
> - Система может не прислать корректный ответ или сбросить соединение
> 
> А согласно PACELC-теореме, как бы вы классифицировали данные реализации?

</details>
<details><summary>Задача 2 - Решение</summary>

> Данные записываются на все узлы с задержкой до часа (асинхронная запись)

По CAP теореме - AP, т.к. асинхронная запись не может дать гарантию консистентности данных.

По PACELC теореме вероятно PA/EL, т.к. задержки в один час скорей всего будет достаточно чтобы устранить небольшие сетевые проблемы, поэтоум логичней делать упор на отзывчивость.

> При сетевых сбоях, система может разделиться на 2 раздельных кластера

По CAP теореме - AP, т.к. если система функционирует, разделённая на 2 части, она так же не может быть консистентной.

По PACELC теореме вероятно PA/EL: явно не описано как именно система должна работать при разделении, но предположу что имеется в виду "разделиться на 2 части и остаться доступной" - в таком случае то же логично делать упор на доступность.

> Система может не прислать корректный ответ или сбросить соединение

По CAP теореме - CP, т.к. условие доступности требует, чтобы запрос всегда завершался корректным ответом.

По PACELC теореме вероятно PC/EC, судя по описанию доступность не так важна, то есть остаётся согласованность.
</details>

<details><summary>Задача 3 - Решение</summary>

> Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?

Не могут. 

ACID ориентирован на целостность данных, а BASE на их доступность. 

Принцип "Soft-state" в BASE противоречит сути ACID, при этом ни один из принципов ACID прямо не противоречет сути BASE.

Об этом можно судить косвенно: выполнение требований ACID потребует от СУБД сложных механизмов проверки целостности базы после каждой транзакции, что сделает её менее быстрой, чем любая BASE СУБД, которая тоже должна гарантировать целостность, просто с течением времени.
</details> 