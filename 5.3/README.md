## Задача 1

<details>
<summary>.</summary>

> Сценарий выполения задачи:
> 
> - создайте свой репозиторий на https://hub.docker.com;
> - выберете любой образ, который содержит веб-сервер Nginx;
> - создайте свой fork образа;
> - реализуйте функциональность:
> запуск веб-сервера в фоне с индекс-страницей, содержащей HTML-код ниже:
> ```
> <html>
> <head>
> Hey, Netology
> </head>
> <body>
> <h1>I’m DevOps Engineer!</h1>
> </body>
> </html>
> ```
> Опубликуйте созданный форк в своем репозитории и предоставьте ответ в виде ссылки на https://hub.docker.com/username_repo.

</details>

Ссылка на Docker образ https://hub.docker.com/r/panarin0290/devops53

## Задача 2

<details>
<summary>Задание</summary> 

> Посмотрите на сценарий ниже и ответьте на вопрос:
> "Подходит ли в этом сценарии использование Docker контейнеров или лучше подойдет виртуальная машина, физическая машина? Может быть возможны разные варианты?"
> 
> Детально опишите и обоснуйте свой выбор.
> 
> --
> 
> Сценарий:
> 
> - Высоконагруженное монолитное java веб-приложение;
> - Nodejs веб-приложение;
> - Мобильное приложение c версиями для Android и iOS;
> - Шина данных на базе Apache Kafka;
> - Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;
> - Мониторинг-стек на базе Prometheus и Grafana;
> - MongoDB, как основное хранилище данных для java-приложения;
> - Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.

</details>

> Высоконагруженное монолитное java веб-приложение;

Зависит от того, может ли приложение масштабироваться и взаимодействовать с каким-нибудь балансировщиком. Если архитектура это позволяет - то контейнеры будут удобней виртуальных машин, т.к. они быстрей разворачиваются, менее требовательны к месту и прочим ресурсам.

Если в приложение не заложено масштабирование, тогда лучше физическая машина, чтобы не тратить лишние ресурсы на виртуализацию.

> Nodejs веб-приложение;

Докер подойдёт хорошо, т.к. это позволит быстро развернуть приложение со всеми необходимыми библиотеками. 

> Мобильное приложение c версиями для Android и iOS;

Скорей всего нет, т.к. я не нашел информации о какой-то интеграции инструментов разработки под мобильные платформы с Docker. 

Это могло бы пригодиться для автотестов и удобства разработки, чтобы поделиться сборкой приложения с коллегами и запустить его без головной боли. 

> Шина данных на базе Apache Kafka;

Да. Брокеры активно используются в современных распределённых приложениях, доставка приложения через докер на сервера и разработчикам в тестовую среду должна упростить жизнь. 

Ещё очень важно иметь возможность быстро откатиться если приложение обновили, и в продакшене что-то пошло не так. Докер будет особенно удобен чтобы "вернуть как было" один из центральных узлов приложения - шину.

> Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;

Docker подойдёт лучше, так как он будет удобней для кластеризации.

> Мониторинг-стек на базе Prometheus и Grafana;

Докер подойдет для этой задачи хорошо. Разворвачивать node_exporter с Docker скорей всего не стоит, т.к. ему требуется прямой доступ к метрикам ядра, но Prometheus и Grafana можно использовать в Докере. 

> MongoDB, как основное хранилище данных для java-приложения;

Подойдёт Docker. У MongoDB есть официальный образ на [Docker Hub](https://hub.docker.com/_/mongo). 

> Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.

В общем случае, думаю удобней будет виртуальная машина, т.к. серверу GitLab не требуется масштабирование или деплой новой версии несколько раз в день, а виртуальная машина позволит очень удобно делать бекапы и при необходимости мигрировать её в кластере. 

Если в компании повсеместно используются контейнеры - тогда, будет удобней Docker, т.к. инженерам это будет привычней.


## Задача 3

<details>
<summary>.</summary>

> - Запустите первый контейнер из образа ***centos*** c любым тэгом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
> - Запустите второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
> - Подключитесь к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```;
> - Добавьте еще один файл в папку ```/data``` на хостовой машине;
> - Подключитесь во второй контейнер и отобразите листинг и содержание файлов в ```/data``` контейнера.

</details>

1. Запуск контейнеров

    ```bash
    vagrant@server1:~/netologydevops53/3$ docker run -it --rm -d --name centos -v $(pwd)/data:/data centos:latest
    dcdf218d218fa2247621825d82008592c4e31ca8810cc307492be3b85540a888
    vagrant@server1:~/netologydevops53/3$ docker run -it --rm -d --name debian -v $(pwd)/data:/data debian:stable
    4b1ae53ad3108522a1170bf6ae1d3260dc861d7f6e884201e37f7a4a81cf03e7
    ```

2. Файл из контейнера с CentOS

    ```bash
    vagrant@server1:~/netologydevops53/3$ docker exec -it centos bash
    [root@dcdf218d218f /]# echo "Hello Netology from CentOS!" > /data/centos.txt
    [root@dcdf218d218f /]# exit
    ```

3. Файл с хоста

    ```bash
    vagrant@server1:~/netologydevops53/3$ echo "Hellow Netology from Host!" > data/host.txt
    ```
   
4. Файлы в директории `/data` в контейнере с Debian

    ```bash
    vagrant@server1:~/netologydevops53/3$ docker exec -it debian bash
    root@4b1ae53ad310:/# ls -l /data/
    total 8
    -rw-r--r-- 1 root root 28 Nov  13 19:09 centos.txt
    -rw-rw-r-- 1 1000 1000 27 Nov  13 19:10 host.txt
    ```
