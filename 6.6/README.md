# Ответы на домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя

```text
# Получаем список активных операций, которые не возвращали результат:
db.currentOp(
   {
     "active" : true,
     "numYields" : 0,
     "waitingForLock" : false
   }
)

# Затем в ответе находим идентификатор операции opid и передаём это значение в db.killOp()
db.killOp(opid)
```

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

```text
Для понимания причины появления зависающих запросов, необходимо проанализировать запросы,
возможно они слишком сложные или в таблицах нет индексов, или индекс развалился, или сам запрос некорректный.
Чтобы быстро решить данную проблему, не влезая в сам запрос, надо ограничить время выполнения запроса,
например, не больше 2 мин:
db.collection.find().maxTimeMS(120000)
Это позволит избежать появления зависших запросов, сохранить работу БД, а также проанализировать и исправить причины.
```

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

## Ответ:

```text
Если в базе данных есть много ключей, срок действия (TTL) которых истекает в одну и ту же секунду,
и они составляют не менее 25% от текущей совокупности ключей с установленным TTL, Redis может заблокировать
запись новых ключей, чтобы снизить процент ключей, TTL которых уже истек, ниже 25%. Это необходимо для того,
чтобы избежать использования слишком большого количества памяти для ключей, срок действия которых уже истек.

Таким образом, задержки операций записи могут происходить, когда количество ключей, TTL которых истекает в
один и тот же момент, превышает 25%.
```
 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему? Какие пути решения данной проблемы вы можете предложить?

## Ответ:

```text
Скорее всего эта проблема возникла из-за роста количества записей, когда миллионы строк отправляются как часть одного
или нескольких запросов. Следует попробовать увеличить параметр "net_read_timeout" со значения по умолчанию 30 секунд
до 60 секунд или больше, чтобы хватало для завершения передачи данных.
Так же стоит проанализировать хватает ли БД ресурсов (возможно их стоит увеличить), а также проверить состояние сети.
Кроме того, нужно проверить наличие и состояние индексов и актуальность данных, возможно часть данных можно удалить или
хотя бы вынести в отдельную таблицу.
```

## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит? Как бы вы решили данную проблему?

## Ответ:

```text
Это типичный пример недостатка оперативной памяти для PostgreSQL. 
Когда память заканчивается, есть 2 пути:
- Обрушить всю систему или завершить отдельные процессы (приложения) для освобождения памяти
- Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя

Для решения проблемы недостатка памяти необходимо:
- увеличить размер RAM на сервере
- настроить PostgreSQL и выделить достаточный объём памяти
- оптимизировать запросы и проверить наличие и состояние индексов
- возможно секционировать большие таблицы (партиционирование)
- возможно настроить swap на сервере (это немного замедлит работу, но поможет эффективно высвобождать ресурсы)
```
